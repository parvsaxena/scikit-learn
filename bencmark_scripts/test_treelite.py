import treelite.gallery.sklearn
from treelite import *
from sklearn.ensemble import *
import treelite.runtime  
import csv

####### GLOBAL VARIABLES #########
num_trees = 128
dataset_path = 'cifar-10.csv'
toolchain = 'gcc'

def process_tree(sklearn_tree, sklearn_model):
  treelite_tree = treelite.ModelBuilder.Tree()
  # Node #0 is always root for scikit-learn decision trees
  treelite_tree[0].set_root()

  # Iterate over each node: node ID ranges from 0 to [node_count]-1
  for node_id in range(sklearn_tree.node_count):
    process_node(treelite_tree, sklearn_tree, node_id, sklearn_model)

  return treelite_tree


def process_test_node(treelite_tree, sklearn_tree, node_id, sklearn_model):
  # Initialize the test node with given node ID
  treelite_tree[node_id].set_numerical_test_node(
                        feature_id=sklearn_tree.feature[node_id],
                        opname='<=',
                        threshold=sklearn_tree.threshold[node_id],
                        default_left=True,
                        left_child_key=sklearn_tree.children_left[node_id],
                        right_child_key=sklearn_tree.children_right[node_id])


def process_model(sklearn_model):
  # Must specify num_output_group and pred_transform
  builder = treelite.ModelBuilder(num_feature=sklearn_model.n_features_,
                                  num_output_group=sklearn_model.n_classes_,
                                  random_forest=True,
                                  pred_transform='identity_multiclass')
  for i in range(sklearn_model.n_estimators):
    # Process i-th tree and add to the builder
    builder.append( process_tree(sklearn_model.estimators_[i].tree_,
                                 sklearn_model) )

  return builder.commit()


def process_node(treelite_tree, sklearn_tree, node_id, sklearn_model):
  if sklearn_tree.children_left[node_id] == -1:  # leaf node
    process_leaf_node(treelite_tree, sklearn_tree, node_id, sklearn_model)
  else:                                          # test node
    process_test_node(treelite_tree, sklearn_tree, node_id, sklearn_model)


def process_leaf_node(treelite_tree, sklearn_tree, node_id, sklearn_model):
  # Get counts for each label class at this leaf node
  leaf_count = sklearn_tree.value[node_id].squeeze()
  # Compute the probability distribution over label classes
  prob_distribution = leaf_count / leaf_count.sum()
  # The leaf output is the probability distribution
  treelite_tree[node_id].set_leaf_node(prob_distribution)

def load_csv(filename):
    """
    Loads a csv file containin the data, parses it
    and returns numpy arrays the containing the training
    and testing data along with their labels.

    :param filename: the filename
    :return: tuple containing train, test data np arrays and labels
    """

    X_train = []
    X_test = []
    num = 0
    with open(filename,'rt')as f:
        reader = csv.reader(f, delimiter=',')
        for row in reader:
            row_int = [float(item) for item in row]
            row_int.pop()
            X_train.append(row_int)
            X_test.append(int(row[-1]))
            num+=1
            # if num > 10000:
            #     break

    #Note: we return the entire datasest and do not split into train
    #and test for now
    return X_train, X_test

if __name__ == "__main__":
    #load the data from the csv file
    print("Loading data")
    X_train, X_test = load_csv(dataset_path)

    # Train the sklearn model
    print("Fitting sklearn naive")
    clf = RandomForestClassifier(n_estimators=num_trees)
    clf.fit(X_train, X_test)

    # clf is the model object generated by scikit-learn
    model = treelite.gallery.sklearn.import_model(clf)

    #export model to shared library
    print("Generating .so")
    model.export_lib(toolchain=toolchain, libpath='./mymodel_cifar.so', verbose=True)
    params={'parallel_comp': 32}

    #predict from model using treelite's runtime predictor
    predictor = treelite.runtime.Predictor('./mymodel_cifar.so', verbose=True)
    batch = treelite.runtime.Batch.from_npy2d(X_train, rbegin=0, rend=10)
    out_pred = predictor.predict(batch)

    print(out_pred)
